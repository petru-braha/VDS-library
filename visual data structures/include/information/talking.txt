- array errors:

| method      | error type  | message	          |
|:-----------:|:-----------:|:-------------------:|
| shift_left  |	fatal_error | "nothing to shift"  |
| constructor |	fatal_error | "wrong parameters"  |
|             |             |		          |
| insert      |	hard_error  | "bad index"         |
| insert      |	fatal_error | "no more memory"    |
| remove      |	hard_error  | "bad index"         |
| queries     |	hard_error  | "no data"           |
| operator[]  |	hard_error  | "unallocated space" |

- interfaces can not contain data members - except tree - i won't modify it
- currently in my project there are two types of non-instantiable classes:
- interfaces
- private constructors classes: lists
- data structures should be 
	- independent of the base type that it stores. there is just one part of the implementation that requires more analysis: ordering of the elements. the ordering problem is based on sorting and comparisons. the convoluted types should be tested when it comes to this problem, testing them with insertions is redundant;
	- aggregate

- log: getl now throws if it is empty
- to do: yoda, check for more bugs, more error checking for array, optimisation friend methods, proof - robustness of testing; why sorting calls may fail:

- about stack and queues: linked lists, not lists

? returning discussion:
- should insert return index of the last element? returning reference to allow obj.method.method
- i can not allow modifying structures outside of themselves => return constant indexes/nodes

- modifier and specific methods, instance synergy will return reference
- typedefs are used only for constant, iterator, query, synergy