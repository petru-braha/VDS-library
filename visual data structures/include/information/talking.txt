- array errors:

| method      | error type  | message	          |
|:-----------:|:-----------:|:-------------------:|
| shift_left  |	fatal_error | "nothing to shift"  |
| constructor |	fatal_error | "wrong parameters"  |
|             |             |		          |
| insert      |	hard_error  | "bad index"         |
| insert      |	fatal_error | "no more memory"    |
| remove      |	hard_error  | "bad index"         |
| queries     |	hard_error  | "no data"           |
| operator[]  |	hard_error  | "unallocated space" |

- interfaces can not contain data members
- data structures should be 
	- independent of the base type that it stores. there is just one part of the implementation that requires more analysis: ordering of the elements. the ordering problem is based on sorting and comparisons. the convoluted types should be tested when it comes to this problem, testing them with insertions is redundant;
	- aggregate

getl now throws if it is empty
- to do: yoda, check for more bugs, more error checking for array, optimisation friend methods, proof - robustness of testing; why sorting calls may fail:

- modifier and specific methods, instance synergy will return reference
- typedefs are used only for constant, iterator, query, synergy

- returning reference to allow obj.method.method
- i can not allow modifying structures outside of themselves => return constant indexes/nodes

- q&a : should the advanced data structures depend on developer-designed basic structures? - no
	- slow 
	- to much functionality
	- solution: define smaller 

- q&a : data_structure<T> or data_structure<t> as a parameter, where t == typedef const T& t; ? 
	- data_structure<t> won't work, no casts will be done
	- solution: use data_structure<T>

- q&a : & const does not exist

TO DO:
- operator != is not the same with !( operator == )
- equality method